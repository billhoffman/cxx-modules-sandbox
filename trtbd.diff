commit 4006e00c2ad5547a4f7273b46fdb509bf36a0d32
Author: Ben Boeckel <mathstuf@gmail.com>
Date:   Thu Jun 10 13:40:22 2021 -0400

    WIP: p1689r4: initial support
    
    TODO:
    
      - changelog
      - work-directory support
      - header-unit information fields
      - non-utf8 paths
      - figure out why junk gets placed at the end of the file

diff --git a/gcc/c-family/c-opts.cc b/gcc/c-family/c-opts.cc
index 21ff22d1b4f..cff75f6dfeb 100644
--- a/gcc/c-family/c-opts.cc
+++ b/gcc/c-family/c-opts.cc
@@ -76,6 +76,9 @@ static bool verbose;
 /* Dependency output file.  */
 static const char *deps_file;
 
+/* Enhanced dependency output file.  */
+static const char *fdeps_file;
+
 /* The prefix given by -iprefix, if any.  */
 static const char *iprefix;
 
@@ -363,6 +366,23 @@ c_common_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,
       deps_file = arg;
       break;
 
+    case OPT_fdep_format_:
+      if (!strcmp(arg, "trtbd"))
+	cpp_opts->deps.format = DEPS_FMT_TRtbd;
+      else
+	error ("%<-fdep-format=%> unknown format %s", arg);
+      break;
+
+    case OPT_fdep_file_:
+      deps_seen = true;
+      fdeps_file = arg;
+      break;
+
+    case OPT_fdep_output_:
+      deps_seen = true;
+      defer_opt (code, arg);
+      break;
+
     case OPT_MF:
       deps_seen = true;
       deps_file = arg;
@@ -1276,6 +1296,7 @@ void
 c_common_finish (void)
 {
   FILE *deps_stream = NULL;
+  FILE *fdeps_stream = NULL;
 
   /* Note that we write the dependencies even if there are errors. This is
      useful for handling outdated generated headers that now trigger errors
@@ -1298,9 +1319,24 @@ c_common_finish (void)
 	}
     }
 
+  if (cpp_opts->deps.format != DEPS_FMT_NONE)
+    {
+      if (!fdeps_file)
+	fdeps_stream = out_stream;
+      else if (fdeps_file[0] == '-' && fdeps_file[1] == '\0')
+	fdeps_stream = stdout;
+      else
+	{
+	  fdeps_stream = fopen (fdeps_file, "w");
+	  if (!fdeps_stream)
+	    fatal_error (input_location, "opening dependency file %s: %m",
+			 fdeps_file);
+	}
+    }
+
   /* For performance, avoid tearing down cpplib's internal structures
      with cpp_destroy ().  */
-  cpp_finish (parse_in, deps_stream);
+  cpp_finish (parse_in, deps_stream, fdeps_stream);
 
   if (deps_stream && deps_stream != out_stream && deps_stream != stdout
       && (ferror (deps_stream) || fclose (deps_stream)))
@@ -1372,6 +1408,8 @@ handle_deferred_opts (void)
 
 	if (opt->code == OPT_MT || opt->code == OPT_MQ)
 	  deps_add_target (deps, opt->arg, opt->code == OPT_MQ);
+	else if (opt->code == OPT_fdep_output_)
+	  deps_add_output (deps, opt->arg, true);
       }
 }
 
diff --git a/gcc/c-family/c.opt b/gcc/c-family/c.opt
index 9cfd2a6bc4e..6c684394567 100644
--- a/gcc/c-family/c.opt
+++ b/gcc/c-family/c.opt
@@ -256,6 +256,18 @@ MT
 C ObjC C++ ObjC++ Joined Separate MissingArgError(missing makefile target after %qs)
 -MT <target>	Add a target that does not require quoting.
 
+fdep-format=
+C ObjC C++ ObjC++ NoDriverArg Joined MissingArgError(missing format after %qs)
+Format for output dependency information. Supported (\"trtbd\").
+
+fdep-file=
+C ObjC C++ ObjC++ NoDriverArg Joined MissingArgError(missing output path after %qs)
+File for output dependency information.
+
+fdep-output=
+C ObjC C++ ObjC++ NoDriverArg Joined MissingArgError(missing path after %qs)
+-fdep-output=obj.o Output file for the compile step.
+
 P
 C ObjC C++ ObjC++
 Do not generate #line directives.
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index fb3dec4ab0c..9fce1b254e6 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -2755,6 +2755,21 @@ is @option{-fpermitted-flt-eval-methods=c11}.  The default when in a GNU
 dialect (@option{-std=gnu11} or similar) is
 @option{-fpermitted-flt-eval-methods=ts-18661-3}.
 
+@item -fdep-file=@var{file}
+@opindex fdep-file
+Where to write structured dependency information.
+
+@item -fdep-format=@var{format}
+@opindex fdep-format
+The format to use for structured dependency information. @samp{trtbd} is the
+only supported format right now. Note that when this argument is specified, the
+output of @samp{-MF} is stripped of some information (namely C++ modules) so
+that it does not use extended makefile syntax not understood by most tools.
+
+@item -fdep-output=@var{file}
+@opindex fdep-output
+Analogous to @option{-MT} but for structured dependency information.
+
 @item -fplan9-extensions
 @opindex fplan9-extensions
 Accept some non-standard constructs used in Plan 9 code.
diff --git a/gcc/fortran/cpp.cc b/gcc/fortran/cpp.cc
index 364bd0d2a85..0b9df9c02cd 100644
--- a/gcc/fortran/cpp.cc
+++ b/gcc/fortran/cpp.cc
@@ -712,7 +712,7 @@ gfc_cpp_done (void)
 	  FILE *f = fopen (gfc_cpp_option.deps_filename, "w");
 	  if (f)
 	    {
-	      cpp_finish (cpp_in, f);
+	      cpp_finish (cpp_in, f, NULL);
 	      fclose (f);
 	    }
 	  else
@@ -721,7 +721,7 @@ gfc_cpp_done (void)
 			     xstrerror (errno));
 	}
       else
-	cpp_finish (cpp_in, stdout);
+	cpp_finish (cpp_in, stdout, NULL);
     }
 
   cpp_undef_all (cpp_in);
diff --git a/gcc/genmatch.cc b/gcc/genmatch.cc
index 97f6f00fa68..d93d0060508 100644
--- a/gcc/genmatch.cc
+++ b/gcc/genmatch.cc
@@ -5248,7 +5248,7 @@ main (int argc, char **argv)
   dt.gen (stdout, gimple);
 
   /* Finalize.  */
-  cpp_finish (r, NULL);
+  cpp_finish (r, NULL, NULL);
   cpp_destroy (r);
 
   delete operators;
diff --git a/gcc/input.cc b/gcc/input.cc
index b3970613d81..8c7666fdd81 100644
--- a/gcc/input.cc
+++ b/gcc/input.cc
@@ -2223,7 +2223,7 @@ test_lexer (const line_table_case &case_)
   ASSERT_NE (tok, NULL);
   ASSERT_EQ (tok->type, CPP_EOF);
 
-  cpp_finish (parser, NULL);
+  cpp_finish (parser, NULL, NULL);
   cpp_destroy (parser);
 }
 
@@ -2254,7 +2254,7 @@ class cpp_reader_ptr
 
   ~cpp_reader_ptr ()
   {
-    cpp_finish (m_ptr, NULL);
+    cpp_finish (m_ptr, NULL, NULL);
     cpp_destroy (m_ptr);
   }
 
diff --git a/libcpp/include/cpplib.h b/libcpp/include/cpplib.h
index 3eba6f74b57..155c01e9329 100644
--- a/libcpp/include/cpplib.h
+++ b/libcpp/include/cpplib.h
@@ -297,6 +297,9 @@ typedef CPPCHAR_SIGNED_T cppchar_signed_t;
 /* Style of header dependencies to generate.  */
 enum cpp_deps_style { DEPS_NONE = 0, DEPS_USER, DEPS_SYSTEM };
 
+/* Format of header dependencies to generate.  */
+enum cpp_deps_format { DEPS_FMT_NONE = 0, DEPS_FMT_TRtbd };
+
 /* The possible normalization levels, from most restrictive to least.  */
 enum cpp_normalize_level {
   /* In NFKC.  */
@@ -557,6 +560,9 @@ struct cpp_options
     /* Style of header dependencies to generate.  */
     enum cpp_deps_style style;
 
+    /* Format of header dependencies to generate.  */
+    enum cpp_deps_format format;
+
     /* Assume missing files are generated files.  */
     bool missing_files;
 
@@ -1077,9 +1083,9 @@ extern void cpp_post_options (cpp_reader *);
 extern void cpp_init_iconv (cpp_reader *);
 
 /* Call this to finish preprocessing.  If you requested dependency
-   generation, pass an open stream to write the information to,
-   otherwise NULL.  It is your responsibility to close the stream.  */
-extern void cpp_finish (cpp_reader *, FILE *deps_stream);
+   generation, pass open stream(s) to write the information to,
+   otherwise NULL.  It is your responsibility to close the stream(s).  */
+extern void cpp_finish (cpp_reader *, FILE *deps_stream, FILE *fdeps_stream);
 
 /* Call this to release the handle at the end of preprocessing.  Any
    use of the handle after this function returns is invalid.  */
diff --git a/libcpp/include/mkdeps.h b/libcpp/include/mkdeps.h
index 96d64641b1a..3363f750349 100644
--- a/libcpp/include/mkdeps.h
+++ b/libcpp/include/mkdeps.h
@@ -58,15 +58,23 @@ extern void deps_add_module_target (struct mkdeps *, const char *module,
 /* Adds a module dependency.  The module name is copied.  */
 extern void deps_add_module_dep (struct mkdeps *, const char *module);
 
+/* Add an output. */
+extern void deps_add_output (struct mkdeps *, const char *, bool);
+
 /* Add a dependency (appears on the right side of the colon) to the
    deps list.  Dependencies will be printed in the order that they
    were entered with this function.  By convention, the first
    dependency entered should be the primary source file.  */
 extern void deps_add_dep (class mkdeps *, const char *);
 
-/* Write out a deps buffer to a specified file.  The last argument
-   is the number of columns to word-wrap at (0 means don't wrap).  */
-extern void deps_write (const cpp_reader *, FILE *, unsigned int);
+/* Write out a deps buffer to a specified file.  The third argument
+   is the number of columns to word-wrap at (0 means don't wrap).
+   The last argument indicates whether to output extra information
+   (namely modules).  */
+extern void deps_write (const struct cpp_reader *, FILE *, unsigned int, int);
+
+/* Write out a deps buffer to a specified file in TRtbd format.  */
+extern void deps_write_trtbd (const struct mkdeps *, FILE *);
 
 /* Write out a deps buffer to a file, in a form that can be read back
    with deps_restore.  Returns nonzero on error, in which case the
diff --git a/libcpp/init.cc b/libcpp/init.cc
index f4ab83d2145..ac870e3a160 100644
--- a/libcpp/init.cc
+++ b/libcpp/init.cc
@@ -842,7 +842,7 @@ read_original_directory (cpp_reader *pfile)
    Maybe it should also reset state, such that you could call
    cpp_start_read with a new filename to restart processing.  */
 void
-cpp_finish (cpp_reader *pfile, FILE *deps_stream)
+cpp_finish (struct cpp_reader *pfile, FILE *deps_stream, FILE *fdeps_stream)
 {
   /* Warn about unused macros before popping the final buffer.  */
   if (CPP_OPTION (pfile, warn_unused_macros))
@@ -856,8 +856,16 @@ cpp_finish (cpp_reader *pfile, FILE *deps_stream)
   while (pfile->buffer)
     _cpp_pop_buffer (pfile);
 
-  if (deps_stream)
-    deps_write (pfile, deps_stream, 72);
+  cpp_deps_format deps_format = CPP_OPTION (pfile, deps.format);
+  if (deps_format == DEPS_FMT_TRtbd && fdeps_stream)
+    deps_write_trtbd (pfile->deps, fdeps_stream);
+
+  if (CPP_OPTION (pfile, deps.style) != DEPS_NONE
+      && deps_stream)
+    {
+      deps_write (pfile, deps_stream,
+		  72, deps_format == DEPS_FMT_NONE);
+    }
 
   /* Report on headers that could use multiple include guards.  */
   if (CPP_OPTION (pfile, print_include_names))
diff --git a/libcpp/mkdeps.cc b/libcpp/mkdeps.cc
index 30e87d8b4d7..f78f9684f8a 100644
--- a/libcpp/mkdeps.cc
+++ b/libcpp/mkdeps.cc
@@ -81,7 +81,7 @@ public:
   };
 
   mkdeps ()
-    : module_name (NULL), cmi_name (NULL), is_header_unit (false), quote_lwm (0)
+    : primary_output (NULL), module_name (NULL), cmi_name (NULL), is_header_unit (false), quote_lwm (0)
   {
   }
   ~mkdeps ()
@@ -90,6 +90,9 @@ public:
 
     for (i = targets.size (); i--;)
       free (const_cast <char *> (targets[i]));
+    free (const_cast <char *> (primary_output));
+    for (i = outputs.size (); i--;)
+      free (const_cast <char *> (outputs[i]));
     for (i = deps.size (); i--;)
       free (const_cast <char *> (deps[i]));
     for (i = vpath.size (); i--;)
@@ -103,6 +106,8 @@ public:
 public:
   vec<const char *> targets;
   vec<const char *> deps;
+  const char * primary_output;
+  vec<const char *> outputs;
   vec<velt> vpath;
   vec<const char *> modules;
 
@@ -288,6 +293,20 @@ deps_add_default_target (class mkdeps *d, const char *tgt)
     }
 }
 
+/* Adds an output O.  We make a copy, so it need not be a permanent
+   string.  */
+void
+deps_add_output (struct mkdeps *d, const char *o, bool is_primary)
+{
+  o = apply_vpath (d, o);
+  if (is_primary) {
+    if (d->primary_output)
+      d->outputs.push (d->primary_output);
+    d->primary_output = xstrdup (o);
+  } else
+    d->outputs.push (xstrdup (o));
+}
+
 void
 deps_add_dep (class mkdeps *d, const char *t)
 {
@@ -387,7 +406,7 @@ make_write_vec (const mkdeps::vec<const char *> &vec, FILE *fp,
    .PHONY targets for all the dependencies too.  */
 
 static void
-make_write (const cpp_reader *pfile, FILE *fp, unsigned int colmax)
+make_write (const cpp_reader *pfile, FILE *fp, unsigned int colmax, int extra)
 {
   const mkdeps *d = pfile->deps;
 
@@ -398,7 +417,7 @@ make_write (const cpp_reader *pfile, FILE *fp, unsigned int colmax)
   if (d->deps.size ())
     {
       column = make_write_vec (d->targets, fp, 0, colmax, d->quote_lwm);
-      if (CPP_OPTION (pfile, deps.modules) && d->cmi_name)
+      if (extra && CPP_OPTION (pfile, deps.modules) && d->cmi_name)
 	column = make_write_name (d->cmi_name, fp, column, colmax);
       fputs (":", fp);
       column++;
@@ -412,7 +431,7 @@ make_write (const cpp_reader *pfile, FILE *fp, unsigned int colmax)
   if (!CPP_OPTION (pfile, deps.modules))
     return;
 
-  if (d->modules.size ())
+  if (extra && d->modules.size ())
     {
       column = make_write_vec (d->targets, fp, 0, colmax, d->quote_lwm);
       if (d->cmi_name)
@@ -423,7 +442,7 @@ make_write (const cpp_reader *pfile, FILE *fp, unsigned int colmax)
       fputs ("\n", fp);
     }
 
-  if (d->module_name)
+  if (extra && d->module_name)
     {
       if (d->cmi_name)
 	{
@@ -455,7 +474,7 @@ make_write (const cpp_reader *pfile, FILE *fp, unsigned int colmax)
 	}
     }
   
-  if (d->modules.size ())
+  if (extra && d->modules.size ())
     {
       column = fprintf (fp, "CXX_IMPORTS +=");
       make_write_vec (d->modules, fp, column, colmax, 0, ".c++m");
@@ -468,9 +487,202 @@ make_write (const cpp_reader *pfile, FILE *fp, unsigned int colmax)
 /* Really we should be opening fp here.  */
 
 void
-deps_write (const cpp_reader *pfile, FILE *fp, unsigned int colmax)
+deps_write (const struct cpp_reader *pfile, FILE *fp, unsigned int colmax, int extra)
+{
+  make_write (pfile, fp, colmax, extra);
+}
+
+static bool
+is_utf8 (const char *name)
+{
+  int byte_length = 0;
+  int expected_continuations = 0;
+  uint32_t codepoint = 0;
+
+  for (const char* c = name; *c; c++)
+    {
+      int byte = *c;
+
+      // Check for a continuation character.
+      if ((byte & 0xc0) == 0x80) // 10xx_xxxx
+	{
+	  --expected_continuations;
+
+	  if (expected_continuations < 0)
+	    return false;
+
+	  // Add the encoded bits to the codepoint.
+	  codepoint = (codepoint << 6) + (byte & ~0x3f);
+
+	  continue;
+	}
+
+      // Make sure we don't expect more continuation characters
+      // once we don't find one.
+      if (expected_continuations != 0)
+	return false;
+
+      // Invalid because if they appear, it is an attempt to encode an ASCII
+      // character in 2 bytes.
+      if (byte == 0xc0 || byte == 0xc1) // 1100_0000 || 1100_0001
+	return false;
+
+      // Invalid because they would encode codepoints greater than allowed
+      // (0x10FFFF).
+      if (byte > 0xf4)
+	return false;
+
+      // ED-prefixed sequence encoding UTF-16 surrogate halves.
+      if (0xD0FF <= codepoint && codepoint <= 0xDFFF)
+	return false;
+
+      // 0x10FFFF is the highest valid codepoint for UTF-8.
+      if (0x10FFFF < codepoint)
+	return false;
+
+      // Overlong encoding of a codepoint.
+      if (byte_length == 2 && codepoint < 0x0800)
+	return false;
+      if (byte_length == 3 && codepoint < 0x10000)
+	return false;
+
+      // Single byte character.
+      if ((byte & 0x80) == 0x00) // 0xxx_xxxx
+	{
+	  codepoint = byte;
+	  byte_length = expected_continuations = 0;
+	}
+      // Prefix codes.
+      else if ((byte & 0xe0) == 0xc0) // 110x_xxxx
+	{
+	  codepoint = byte & 0x1f;
+	  byte_length = expected_continuations = 1;
+	}
+      else if ((byte & 0xf0) == 0xe0) // 1110_xxxx
+	{
+	  codepoint = byte & 0x0f;
+	  byte_length = expected_continuations = 2;
+	}
+      else if ((byte & 0xf8) == 0xf0) // 1111_0xxx
+	{
+	  codepoint = byte & 0x07;
+	  byte_length = expected_continuations = 3;
+	}
+      else
+	return false;
+    }
+
+  if (expected_continuations != 0)
+    return false;
+
+  return true;
+}
+
+static void
+trtbd_write_filepath (const char *name, FILE *fp)
 {
-  make_write (pfile, fp, colmax);
+  if (is_utf8 (name))
+    {
+      fputc ('"', fp);
+      for (const char* c = name; *c; c++)
+	{
+	  // Escape control characters.
+	  if (ISCNTRL (*c))
+	    fprintf (fp, "\\u%04x", *c);
+	  // JSON escape characters.
+	  else if (*c == '"' || *c == '\\')
+	    {
+	      fputc ('\\', fp);
+	      fputc (*c, fp);
+	    }
+	  // Everything else.
+	  else
+	    fputc (*c, fp);
+	}
+      fputc ('"', fp);
+    }
+  else
+    {
+      // TODO: print an error
+    }
+}
+
+static void
+trtbd_write_vec (const mkdeps::vec<const char *> &vec, FILE *fp)
+{
+  for (unsigned ix = 0; ix != vec.size (); ix++)
+    {
+      trtbd_write_filepath (vec[ix], fp);
+      if (ix < vec.size () - 1)
+	fputc (',', fp);
+      fputc ('\n', fp);
+    }
+}
+
+void
+deps_write_trtbd (const struct mkdeps *d, FILE *fp)
+{
+  fputs ("{\n", fp);
+
+  fputs ("\"rules\": [\n", fp);
+  fputs ("{\n", fp);
+
+  // work-directory
+
+  if (d->primary_output)
+    {
+      fputs ("\"primary-output\": ", fp);
+      trtbd_write_filepath (d->primary_output, fp);
+      fputs (",\n", fp);
+    }
+
+  if (d->outputs.size ())
+    {
+      fputs ("\"outputs\": [\n", fp);
+      trtbd_write_vec (d->outputs, fp);
+      fputs ("],\n", fp);
+    }
+
+  if (d->module_name)
+    {
+      fputs ("\"provides\": [\n", fp);
+      fputs ("{\n", fp);
+
+      fputs ("\"logical-name\": ", fp);
+      trtbd_write_filepath (d->module_name, fp);
+      fputs ("\n", fp);
+
+      // other information
+
+      fputs ("}\n", fp);
+      fputs ("],\n", fp);
+    }
+
+  fputs ("\"requires\": [\n", fp);
+  for (size_t i = 0; i < d->modules.size (); i++)
+    {
+      if (i != 0)
+	fputs (",\n", fp);
+      fputs ("{\n", fp);
+
+      fputs ("\"logical-name\": ", fp);
+      trtbd_write_filepath (d->modules[i], fp);
+      fputs ("\n", fp);
+
+      // other information
+
+      fputs ("}\n", fp);
+    }
+  fputs ("]\n", fp);
+
+  fputs ("}\n", fp);
+
+  fputs ("],\n", fp);
+
+  fputs ("\"version\": 0,\n", fp);
+  fputs ("\"revision\": 0\n", fp);
+
+  fputs ("}\n", fp);
 }
 
 /* Write out a deps buffer to a file, in a form that can be read back
