diff --git a/gcc/c-family/c-opts.c b/gcc/c-family/c-opts.c
index dd65b3b8c30..da56c7c3f21 100644
--- a/gcc/c-family/c-opts.c
+++ b/gcc/c-family/c-opts.c
@@ -76,6 +76,9 @@ static bool verbose;
 /* Dependency output file.  */
 static const char *deps_file;
 
+/* Enhanced dependency output file.  */
+static const char *fdeps_file;
+
 /* The prefix given by -iprefix, if any.  */
 static const char *iprefix;
 
@@ -353,6 +356,23 @@ c_common_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,
       deps_file = arg;
       break;
 
+    case OPT_fdep_format_:
+      if (!strcmp(arg, "trtbd"))
+	cpp_opts->deps.format = DEPS_FMT_TRtbd;
+      else
+	error ("%<-fdep-format=%> unknown format %s", arg);
+      break;
+
+    case OPT_fdep_file_:
+      deps_seen = true;
+      fdeps_file = arg;
+      break;
+
+    case OPT_fdep_output_:
+      deps_seen = true;
+      defer_opt (code, arg);
+      break;
+
     case OPT_MF:
       deps_seen = true;
       deps_file = arg;
@@ -1248,6 +1268,7 @@ void
 c_common_finish (void)
 {
   FILE *deps_stream = NULL;
+  FILE *fdeps_stream = NULL;
 
   /* Note that we write the dependencies even if there are errors. This is
      useful for handling outdated generated headers that now trigger errors
@@ -1270,9 +1291,24 @@ c_common_finish (void)
 	}
     }
 
+  if (cpp_opts->deps.format != DEPS_FMT_NONE)
+    {
+      if (!fdeps_file)
+	fdeps_stream = out_stream;
+      else if (fdeps_file[0] == '-' && fdeps_file[1] == '\0')
+	fdeps_stream = stdout;
+      else
+	{
+	  fdeps_stream = fopen (fdeps_file, "w");
+	  if (!fdeps_stream)
+	    fatal_error (input_location, "opening dependency file %s: %m",
+			 fdeps_file);
+	}
+    }
+
   /* For performance, avoid tearing down cpplib's internal structures
      with cpp_destroy ().  */
-  cpp_finish (parse_in, deps_stream);
+  cpp_finish (parse_in, deps_stream, fdeps_stream);
 
   if (deps_stream && deps_stream != out_stream && deps_stream != stdout
       && (ferror (deps_stream) || fclose (deps_stream)))
@@ -1344,6 +1380,8 @@ handle_deferred_opts (void)
 
 	if (opt->code == OPT_MT || opt->code == OPT_MQ)
 	  deps_add_target (deps, opt->arg, opt->code == OPT_MQ);
+	else if (opt->code == OPT_fdep_output_)
+	  deps_add_output (deps, opt->arg);
       }
 }
 
diff --git a/gcc/c-family/c.opt b/gcc/c-family/c.opt
index 265e4054412..1d8d7d7f6e0 100644
--- a/gcc/c-family/c.opt
+++ b/gcc/c-family/c.opt
@@ -256,6 +256,18 @@ MT
 C ObjC C++ ObjC++ Joined Separate MissingArgError(missing makefile target after %qs)
 -MT <target>	Add a target that does not require quoting.
 
+fdep-format=
+C ObjC C++ ObjC++ NoDriverArg Joined MissingArgError(missing format after %qs)
+Format for output dependency information. Supported (\"trtbd\").
+
+fdep-file=
+C ObjC C++ ObjC++ NoDriverArg Joined MissingArgError(missing output path after %qs)
+File for output dependency information.
+
+fdep-output=
+C ObjC C++ ObjC++ NoDriverArg Joined MissingArgError(missing path after %qs)
+-fdep-output=obj.o Output file for the compile step.
+
 P
 C ObjC C++ ObjC++
 Do not generate #line directives.
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index 93755f1feb5..0f9d9520ad7 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -2758,6 +2758,21 @@ An oracle to query for module name to filename mappings.  If
 unspecified the @env{CXX_MODULE_MAPPER} environment variable is used,
 and if that is unset, a default is provided.
 
+@item -fdep-file=@var{file}
+@opindex fdep-file
+Where to write structured dependency information.
+
+@item -fdep-format=@var{format}
+@opindex fdep-format
+The format to use for structured dependency information. @samp{trtbd} is the
+only supported format right now. Note that when this argument is specified, the
+output of @samp{-MF} is stripped of some information (namely C++ modules) so
+that it does not use extended makefile syntax not understood by most tools.
+
+@item -fdep-output=@var{file}
+@opindex fdep-output
+Analogous to @option{-MT} but for structured dependency information.
+
 @item -fms-extensions
 @opindex fms-extensions
 Disable Wpedantic warnings about constructs used in MFC, such as implicit
diff --git a/gcc/fortran/cpp.c b/gcc/fortran/cpp.c
index 51baf141711..ea990831edc 100644
--- a/gcc/fortran/cpp.c
+++ b/gcc/fortran/cpp.c
@@ -683,7 +683,7 @@ gfc_cpp_done (void)
 	  FILE *f = fopen (gfc_cpp_option.deps_filename, "w");
 	  if (f)
 	    {
-	      cpp_finish (cpp_in, f);
+	      cpp_finish (cpp_in, f, NULL);
 	      fclose (f);
 	    }
 	  else
@@ -692,7 +692,7 @@ gfc_cpp_done (void)
 			     xstrerror (errno));
 	}
       else
-	cpp_finish (cpp_in, stdout);
+	cpp_finish (cpp_in, stdout, NULL);
     }
 
   cpp_undef_all (cpp_in);
diff --git a/gcc/genmatch.c b/gcc/genmatch.c
index 0a8cba62e0c..a40c52dbfaa 100644
--- a/gcc/genmatch.c
+++ b/gcc/genmatch.c
@@ -5183,7 +5183,7 @@ main (int argc, char **argv)
   dt.gen (stdout, gimple);
 
   /* Finalize.  */
-  cpp_finish (r, NULL);
+  cpp_finish (r, NULL, NULL);
   cpp_destroy (r);
 
   delete operators;
diff --git a/gcc/input.c b/gcc/input.c
index 8fe5d4282c6..a58b2ea386e 100644
--- a/gcc/input.c
+++ b/gcc/input.c
@@ -2061,7 +2061,7 @@ test_lexer (const line_table_case &case_)
   ASSERT_NE (tok, NULL);
   ASSERT_EQ (tok->type, CPP_EOF);
 
-  cpp_finish (parser, NULL);
+  cpp_finish (parser, NULL, NULL);
   cpp_destroy (parser);
 }
 
@@ -2092,7 +2092,7 @@ class cpp_reader_ptr
 
   ~cpp_reader_ptr ()
   {
-    cpp_finish (m_ptr, NULL);
+    cpp_finish (m_ptr, NULL, NULL);
     cpp_destroy (m_ptr);
   }
 
diff --git a/libcpp/include/cpplib.h b/libcpp/include/cpplib.h
index 13a5ad806bd..576f3701509 100644
--- a/libcpp/include/cpplib.h
+++ b/libcpp/include/cpplib.h
@@ -295,6 +295,9 @@ typedef CPPCHAR_SIGNED_T cppchar_signed_t;
 /* Style of header dependencies to generate.  */
 enum cpp_deps_style { DEPS_NONE = 0, DEPS_USER, DEPS_SYSTEM };
 
+/* Format of header dependencies to generate.  */
+enum cpp_deps_format { DEPS_FMT_NONE = 0, DEPS_FMT_TRtbd };
+
 /* The possible normalization levels, from most restrictive to least.  */
 enum cpp_normalize_level {
   /* In NFKC.  */
@@ -527,6 +530,9 @@ struct cpp_options
     /* Style of header dependencies to generate.  */
     enum cpp_deps_style style;
 
+    /* Format of header dependencies to generate.  */
+    enum cpp_deps_format format;
+
     /* Assume missing files are generated files.  */
     bool missing_files;
 
@@ -1028,9 +1034,9 @@ extern void cpp_post_options (cpp_reader *);
 extern void cpp_init_iconv (cpp_reader *);
 
 /* Call this to finish preprocessing.  If you requested dependency
-   generation, pass an open stream to write the information to,
-   otherwise NULL.  It is your responsibility to close the stream.  */
-extern void cpp_finish (cpp_reader *, FILE *deps_stream);
+   generation, pass open stream(s) to write the information to,
+   otherwise NULL.  It is your responsibility to close the stream(s).  */
+extern void cpp_finish (cpp_reader *, FILE *deps_stream, FILE *fdeps_stream);
 
 /* Call this to release the handle at the end of preprocessing.  Any
    use of the handle after this function returns is invalid.  */
diff --git a/libcpp/include/mkdeps.h b/libcpp/include/mkdeps.h
index 1d6dd9562a5..0793b3bfd8e 100644
--- a/libcpp/include/mkdeps.h
+++ b/libcpp/include/mkdeps.h
@@ -51,6 +51,9 @@ extern void deps_add_target (class mkdeps *, const char *, int);
    string as the default target is interpreted as stdin.  */
 extern void deps_add_default_target (class mkdeps *, const char *);
 
+/* Add an output. */
+extern void deps_add_output (struct mkdeps *, const char *);
+
 /* Add a dependency (appears on the right side of the colon) to the
    deps list.  Dependencies will be printed in the order that they
    were entered with this function.  By convention, the first
@@ -60,9 +63,14 @@ extern void deps_add_dep (class mkdeps *, const char *);
 extern void deps_add_module (struct mkdeps *, const char *,
 			     const char * = NULL, bool = false);
 
-/* Write out a deps buffer to a specified file.  The last argument
-   is the number of columns to word-wrap at (0 means don't wrap).  */
-extern void deps_write (const cpp_reader *, FILE *, unsigned int);
+/* Write out a deps buffer to a specified file.  The third argument
+   is the number of columns to word-wrap at (0 means don't wrap).
+   The last argument indicates whether to output extra information
+   (namely modules).  */
+extern void deps_write (const struct cpp_reader *, FILE *, unsigned int, int);
+
+/* Write out a deps buffer to a specified file in TRtbd format.  */
+extern void deps_write_trtbd (const struct mkdeps *, FILE *);
 
 /* Write out a deps buffer to a file, in a form that can be read back
    with deps_restore.  Returns nonzero on error, in which case the
diff --git a/libcpp/init.c b/libcpp/init.c
index 3212e01fbb5..b457eb0c509 100644
--- a/libcpp/init.c
+++ b/libcpp/init.c
@@ -787,7 +787,7 @@ read_original_directory (cpp_reader *pfile)
    Maybe it should also reset state, such that you could call
    cpp_start_read with a new filename to restart processing.  */
 void
-cpp_finish (cpp_reader *pfile, FILE *deps_stream)
+cpp_finish (struct cpp_reader *pfile, FILE *deps_stream, FILE *fdeps_stream)
 {
   /* Warn about unused macros before popping the final buffer.  */
   if (CPP_OPTION (pfile, warn_unused_macros))
@@ -801,8 +801,16 @@ cpp_finish (cpp_reader *pfile, FILE *deps_stream)
   while (pfile->buffer)
     _cpp_pop_buffer (pfile);
 
-  if (deps_stream)
-    deps_write (pfile, deps_stream, 72);
+  cpp_deps_format deps_format = CPP_OPTION (pfile, deps.format);
+  if (deps_format == DEPS_FMT_TRtbd && fdeps_stream)
+    deps_write_trtbd (pfile->deps, fdeps_stream);
+
+  if (CPP_OPTION (pfile, deps.style) != DEPS_NONE
+      && deps_stream)
+    {
+      deps_write (pfile, deps_stream,
+		  72, deps_format == DEPS_FMT_NONE);
+    }
 
   /* Report on headers that could use multiple include guards.  */
   if (CPP_OPTION (pfile, print_include_names))
diff --git a/libcpp/mkdeps.c b/libcpp/mkdeps.c
index beb8442be5d..e92b52e4f51 100644
--- a/libcpp/mkdeps.c
+++ b/libcpp/mkdeps.c
@@ -90,6 +90,8 @@ public:
 
     for (i = targets.size (); i--;)
       free (const_cast <char *> (targets[i]));
+    for (i = outputs.size (); i--;)
+      free (const_cast <char *> (outputs[i]));
     for (i = deps.size (); i--;)
       free (const_cast <char *> (deps[i]));
     for (i = vpath.size (); i--;)
@@ -102,6 +104,7 @@ public:
 
 public:
   vec<const char *> targets;
+  vec<const char *> outputs;
   vec<const char *> deps;
   vec<velt> vpath;
   vec<const char *> modules;
@@ -299,6 +302,15 @@ deps_add_default_target (class mkdeps *d, const char *tgt)
     }
 }
 
+/* Adds an output O.  We make a copy, so it need not be a permanent
+   string.  */
+void
+deps_add_output (struct mkdeps *d, const char *o)
+{
+  o = apply_vpath (d, o);
+  d->outputs.push (xstrdup (o));
+}
+
 void
 deps_add_dep (class mkdeps *d, const char *t)
 {
@@ -397,7 +409,7 @@ make_write_vec (const mkdeps::vec<const char *> &vec, FILE *fp,
    .PHONY targets for all the dependencies too.  */
 
 static void
-make_write (const cpp_reader *pfile, FILE *fp, unsigned int colmax)
+make_write (const cpp_reader *pfile, FILE *fp, unsigned int colmax, int extra)
 {
   const mkdeps *d = pfile->deps;
 
@@ -408,7 +420,7 @@ make_write (const cpp_reader *pfile, FILE *fp, unsigned int colmax)
   if (d->deps.size ())
     {
       column = make_write_vec (d->targets, fp, 0, colmax, d->quote_lwm);
-      if (CPP_OPTION (pfile, deps.modules) && d->bmi_name)
+      if (extra && CPP_OPTION (pfile, deps.modules) && d->bmi_name)
 	column = make_write_name (d->bmi_name, fp, column, colmax);
       fputs (":", fp);
       column++;
@@ -422,7 +434,7 @@ make_write (const cpp_reader *pfile, FILE *fp, unsigned int colmax)
   if (!CPP_OPTION (pfile, deps.modules))
     return;
 
-  if (d->modules.size ())
+  if (extra && d->modules.size ())
     {
       column = make_write_vec (d->targets, fp, 0, colmax, d->quote_lwm);
       if (d->bmi_name)
@@ -433,7 +445,7 @@ make_write (const cpp_reader *pfile, FILE *fp, unsigned int colmax)
       fputs ("\n", fp);
     }
 
-  if (d->module_name)
+  if (extra && d->module_name)
     {
       if (d->bmi_name)
 	{
@@ -465,7 +477,7 @@ make_write (const cpp_reader *pfile, FILE *fp, unsigned int colmax)
 	}
     }
   
-  if (d->modules.size ())
+  if (extra && d->modules.size ())
     {
       column = fprintf (fp, "CXX_IMPORTS +=");
       make_write_vec (d->modules, fp, column, colmax, 0, ".c++m");
@@ -478,9 +490,226 @@ make_write (const cpp_reader *pfile, FILE *fp, unsigned int colmax)
 /* Really we should be opening fp here.  */
 
 void
-deps_write (const cpp_reader *pfile, FILE *fp, unsigned int colmax)
+deps_write (const struct cpp_reader *pfile, FILE *fp, unsigned int colmax, int extra)
+{
+  make_write (pfile, fp, colmax, extra);
+}
+
+static bool
+is_utf8 (const char *name)
+{
+  int byte_length = 0;
+  int expected_continuations = 0;
+  uint32_t codepoint = 0;
+
+  for (const char* c = name; *c; c++)
+    {
+      int byte = *c;
+
+      // Check for a continuation character.
+      if ((byte & 0xc0) == 0x80)
+	{
+	  --expected_continuations;
+
+	  if (expected_continuations < 0)
+	    return false;
+
+	  // Add the encoded bits to the codepoint.
+	  codepoint = (codepoint << 6) + (byte & ~0x3f);
+
+	  continue;
+	}
+
+      // Make sure we don't expect more continuation characters
+      // once we don't find one.
+      if (expected_continuations != 0)
+	return false;
+
+      // Invalid because if they appear, it is an attempt to encode an ASCII
+      // character in 2 bytes.
+      if (byte == 0xc0 || byte == 0xc1)
+	return false;
+
+      // Invalid because they would encode codepoints greater than allowed
+      // (0x10FFFF).
+      if (byte > 0xf4)
+	return false;
+
+      // ED-prefixed sequence encoding UTF-16 surrogate halves.
+      if (0xD0FF <= codepoint && codepoint <= 0xDFFF)
+	return false;
+
+      // 0x10FFFF is the highest valid codepoint for UTF-8.
+      if (0x10FFFF < codepoint)
+	return false;
+
+      // Overlong encoding of a codepoint.
+      if (byte_length == 2 && codepoint < 0x0800)
+	return false;
+      if (byte_length == 3 && codepoint < 0x10000)
+	return false;
+
+      // Single byte character.
+      if ((byte & 0x80) == 0x00)
+	{
+	  codepoint = byte;
+	  byte_length = expected_continuations = 0;
+	}
+      // Prefix codes.
+      else if ((byte & 0xe0) == 0xc0)
+	{
+	  codepoint = byte & 0x1f;
+	  byte_length = expected_continuations = 1;
+	}
+      else if ((byte & 0xf0) == 0xe0)
+	{
+	  codepoint = byte & 0x0f;
+	  byte_length = expected_continuations = 2;
+	}
+      else if ((byte & 0xf8) == 0xf0)
+	{
+	  codepoint = byte & 0x07;
+	  byte_length = expected_continuations = 3;
+	}
+      else
+	return false;
+    }
+
+  if (expected_continuations != 0)
+    return false;
+
+  return true;
+}
+
+static void
+trtbd_write_filepath (const char *name, FILE *fp)
+{
+  if (is_utf8 (name))
+    {
+      fputc ('"', fp);
+      for (const char* c = name; *c; c++)
+	{
+	  // Escape control characters.
+	  if (ISCNTRL (*c))
+	    fprintf (fp, "\\u%04x", *c);
+	  // JSON escape characters.
+	  else if (*c == '"' || *c == '\\')
+	    {
+	      fputc ('\\', fp);
+	      fputc (*c, fp);
+	    }
+	  // Everything else.
+	  else
+	    fputc (*c, fp);
+	}
+      fputc ('"', fp);
+    }
+  else
+    {
+      fputs ("{\n", fp);
+
+      // TODO: Add `readable` output.
+
+      // 8-bit raw data.
+      fputs ("\"format\": \"raw8\",\n", fp);
+      fputs ("\"code-units\": [\n", fp);
+
+      // Output the bytes of the filepath as an array of integers.
+      const char* c = name;
+      fprintf (fp, "%d", *c);
+      for (++c; *c; c++)
+	fprintf (fp, ",%d", *c);
+
+      fputs ("]\n", fp);
+
+      fputs ("}", fp);
+    }
+}
+
+static void
+trtbd_write_vec (const mkdeps::vec<const char *> &vec, FILE *fp)
+{
+  for (unsigned ix = 0; ix != vec.size (); ix++)
+    {
+      trtbd_write_filepath (vec[ix], fp);
+      if (ix < vec.size () - 1)
+	fputc (',', fp);
+      fputc ('\n', fp);
+    }
+}
+
+void
+deps_write_trtbd (const struct mkdeps *d, FILE *fp)
 {
-  make_write (pfile, fp, colmax);
+  fputs ("{\n", fp);
+
+  fputs ("\"rules\": [\n", fp);
+  fputs ("{\n", fp);
+
+  fputs ("\"inputs\": [", fp);
+  trtbd_write_filepath (d->deps[0], fp);
+  fputs ("],\n", fp);
+
+  fputs ("\"outputs\": [\n", fp);
+  trtbd_write_vec (d->targets, fp);
+  fputs ("],\n", fp);
+
+  fputs ("\"future-compile\": {\n", fp);
+
+  if (d->outputs.size ())
+    {
+      fputs ("\"outputs\": [\n", fp);
+      trtbd_write_vec (d->outputs, fp);
+      fputs ("],\n", fp);
+    }
+
+  if (d->module_name)
+    {
+      fputs ("\"provides\": [\n", fp);
+      fputs ("{\n", fp);
+
+      fputs ("\"logical-name\": ", fp);
+      trtbd_write_filepath (d->module_name, fp);
+      fputs ("\n", fp);
+
+      fputs ("}\n", fp);
+      fputs ("],\n", fp);
+    }
+
+  fputs ("\"requires\": [\n", fp);
+  for (size_t i = 0; i < d->modules.size (); i++)
+    {
+      if (i != 0)
+	fputs (",\n", fp);
+      fputs ("{\n", fp);
+
+      fputs ("\"logical-name\": ", fp);
+      trtbd_write_filepath (d->modules[i], fp);
+      fputs ("\n", fp);
+
+      fputs ("}\n", fp);
+    }
+  fputs ("]\n", fp);
+
+  fputs ("},\n", fp);
+
+  fputs ("\"depends\": [\n", fp);
+  trtbd_write_vec (d->deps, fp);
+  fputs ("]\n", fp);
+
+  fputs ("}\n", fp);
+  fputs ("],\n", fp);
+
+  char *curdir = get_current_dir_name ();
+  fputs ("\"work-directory\": ", fp);
+  trtbd_write_filepath (curdir, fp);
+  free (curdir);
+  fputs (",\n", fp);
+
+  fputs ("\"version\": 0,\n", fp);
+  fputs ("\"revision\": 0\n", fp);
+
+  fputs ("}\n", fp);
 }
 
 /* Write out a deps buffer to a file, in a form that can be read back
